# Lab 17.4
## [Task 1](https://github.com/LostDit/Lab-17.4/blob/master/Task%201/Task%201.cpp)
### Что нужно сделать:
Напишите функцию, принимающую два указателя на int и меняющую местами содержимое этих указателей.
### Чек-лист для проверки задачи
* Функция принимает корректные типы данных, тип возвращаемого значения — void.
* Функция не использует библиотеки, кроме <iostream>.
* Функция меняет значения по указателям.
-----------
## [Task 2](https://github.com/LostDit/Lab-17.4/blob/master/Task%202/Task%202.cpp)
### Что нужно сделать:
Напишите функцию, принимающую указатель на тип int, по которому размещены десять переменных типа int. Функция ничего не возвращает, но по тому же указателю элементы должны располагаться в обратном порядке.
### Чек-лист для проверки задачи
* Функция принимает корректные типы данных, тип возвращаемого значения — void.
* Функция не использует библиотеки, кроме <iostream>.
* По переданному указателю переменные располагаются в обратном порядке.
-----------
## [Task 3](https://github.com/LostDit/Lab-17.4/tree/master/Task%203)
### Что нужно сделать:
Напишите функцию, принимающую два указателя на char*, по которым размещены две строки.

Функция должна возвращать true, если вторая строка является подстрокой первой.
### Пример:
```
const char* a = "Hello world";
const char* b = "wor";
const char* c = "banana";
std::cout << substr(a,b) << " " << substr(a,c);
// true false
```
### Const-квалификатор

Const является квалификатором типа, применяемым к переменным, значения которых нельзя изменять.
Например, если в коде написать:

const int a = 2;

то впоследствии значение переменной невозможно будет изменить, а запись вида

a = 3;

приведёт к ошибке компилятора.

### Чек-лист для проверки задачи
* Функция принимает корректные типы данных, тип возвращаемого значения — bool.
* Для работы со строками разрабатываемая функция может использовать только стандартную функцию strlen, входящую в библиотеку <cstring>. Допускается не использовать стандартные функции, а размер строки определять по нуль-символу ‘\0’.
* Функция корректно определяет, является ли вторая строка подстрокой первой.
